인사이드 코딩 문제기록문서

서론.
나는 이제껏 내가 만들고 싶은 게임을 만들기 위해 여러 지식을 습득해왔다.
하지만, 게임과는 별개로, 지식을 얻으면 얻을 수록 점점 내가 할 수 있는 것들이 매우 크게 확장되는 것을 느꼈고, 때문에 그 가능성들을 보게 될 것이라는 생각에 매일 심장이 떨렸다.
마치 포인터와 함수, 배열, 여러 연산, 라이브러리등을 배웠을 때와 같이 말이다.
하지만, 구조체를 배우게 되었을때, 또 한번 생각의 확장을 경험했지만, 그것이 나의 마지막 확장이었다.
어디를 찾아봐도 뭔가 나에게 더욱 뭔가 가능성을 제시하는 것들이 없어졌을때,
한참 뒤에야 내가 그 가능성을 만들 수도 있다고 생각했고, 
그렇게 만든게 이것이다. 프로그램에서 실시간으로 코드를 생성하고 번역하는 기능.
그것이 인사이드 코딩이다.

인사이드 코딩을 개발하는 이유는 코드를 작성할때 보다 많은 명령과 다양한 가능성으로 코딩을 확장하기 위해서였는데, 그 중 하나는 다음과 같다.

if(c == 5){
}
만약 스레드가 2개 있고, 다음과 같은 코드가 있다고 할때, 다른스레드에서 c를 변경했다고 하면, 
c가 5가 아니기 때문에 원하지 않는 결과가 나타날 수 있다.
이럴때

if(c == 5) absolute: {
}
이렇게 하면 이 if문 실행시에는 c를 변경시킬 수 없게 하거나, c가 변하면, 실행되었던 것들을 모두 취소하고 중괄호를 빠져나오는 결과를 도출할 수 있다.

실재로는 이런 것이 없지만, 인사이드 코딩을 통해 이것을 만들어낼 수 있기 때문에 만든다.

///
2020 10 19일이다.
시험기간이지만, 심심해서 약간 개발했다.
오늘은 SetVariable 함수를 만들었다.
원래는 SetVariable 함수는 보통, 데이터에 값을 넣는 함수다.
그리고 set코드 즉,
a = 10+ 5-6; 이런 코드를 해석하고 실행하는데 쓰는 함수다.
지금은 +와 -만 연산자로 치고 간단하게 만들어봤다.
이 함수가 "a = "를 제외한 문자열에서 식만을 보고 값을 추출해내는 함수다.
"10 + 5 - 6"이 입력되면, 9가 반환된다.
int GetDataOperation(vector<textblock*> expression, InsideCode IC);
이 함수를 만들때, 각 택스트블록이 어떤 것을 뜻하는지 어떤 종류인지 반환해주는 함수가 필요한데, 그 이유는
"a", "+", "152" 와같은 다른것들을 뜻하는 문자들을 구분하기 위해서였다.
그래서 이 함수를 만들었다.
string DecodeTextBlock(textblock t)
이 함수는 t가 어떤 종류를 뜻하는지 반환해주는 역할이다.
지금은 "num", "str", "operator", "null" 만 있다.
이 함수는 여러가지에 많이 쓰일 것 같다.

그래서 이것을 통해 지금은 +-만 구현했다.
여러 시행착오 끝에 
var a;
a = 1;
var b;
var c;
b = 5;
c = b + a;
이 코드가 잘 실행되는 것을 확인했다.
다음 목표는 *, /를 구현하는 것이 되겠다.

개발하다보니 if문도 만들고 싶어졌다.
if문의 작동원리는 다음과 같다.
if 문은 그 존재로 2개의 코드블록을 나란히 연속되게 잡아먹게 되는데,
if(<조건문>)
{c = c + 1; a = a + 1;}
이 두가지로 나뉘게 된다.
때문에 if문은 조건을 확인한후, true면 건너뛰지 않고 그대로 실행하고,
false면 한칸을 건너뛰어야 한다.
그려러면 몇번째 코드를 실행하고 있는지에 대한 포인터가 필요하다.
if문의 조건이 맞지 않을때, 그 변수의 값을 1더해야 하기 때문이다.

for (int i = 0; i < IC->code.size(); i++) {
		CodeBlock* code = IC->code.at(i);
		StepCode(code, IC);
	}
이것이 기존의 코드다. 여기에서는 i가 그 역할을 하고 있으므로, 
StepCode는 다음과 같이 바뀔 필요가 있다고 생각했다.
void StepCode(CodeBlock* code, InsideCode* IC); // 기존
void StepCode(CodeBlock* code, InsideCode* IC, int* i); // 바뀐 후

그러면 결과적으로 if문의 코드가 할 일은 단지 조건이 맞나 맞지않냐를 확인하는 일일 뿐이다.
그 전에 택스트블록에서 "=="가 =두개로 인식하여 "=" "="로 나타나는 현상이 있었으니 그것을 먼저 고쳐야 한다.
그리고 조건식을 검사하는 함수가 따로 있어야 한다고 생각했다.
왜냐하면 조건식은 일반식에서도, if, while, for에도 쓰이기 때문이다. 
일단 if문을 실행시키는 함수는 이렇다.
bool Execute_if(CodeBlock* code, InsideCode* IC);
그리고 조건식을 판단하는 함수는 이렇다.
bool JudgeConditionalExpression(vector<textblock*> expression, InsideCode* IC)
지금은 이 함수에서 && || !등을 포함하지 않는 간단한 것들만 처리할 예정이다.

택스트블록에서 "=="가 =두개로 인식하여 "=" "="로 나타나는 현상을 고쳤다.
프로젝트에서 택스트블록을 나눌때, 맨끝의 글자가 어떤 아스키인지 살펴보고, 나눌지 아닐지 결정하는
코드가 있었는데, =가 나오면 나누지 않게 했음. 그렇게 했는데 잘되긴 함.
근데 나중에 문제가 발생할 것 같아 지웠다.
무슨 문제냐면, a=1일때, =의 처리를 하면 코드가 복잡해진다고 생각했다.
그래서 택스트블록을 만든다음, =, ! < >등을 연결시켜주는 코드를 뒤에 달았다.

조건문까지 간단하게 만들었다.
어느정도까지 되냐하면 <= >= == != < >가 되고, int만 비교가능하다.
아직 자료형이 int밖에 없기 때문이다.
그리고 식이 들어가면 해석을 하지 못할 수 있다.
아직 식은 해석을 못한다.
a == 1같은 거는 가능한데, (a+b*c) > 5 같은거는 불가능.

while문을 만들었다.
함수는 void Execute_While(CodeBlock* code, InsideCode* IC, int* i);
이다.
while (true) {
	bool returnbool = JudgeConditionalExpression(e, IC); // 조건이 맞는지 검사
	if (returnbool) { // true면
		CodeBlock* code2 = IC->code.at(*i+1); //i+1의 코드실행
		StepCode(code2, IC, i); // 여기에서 i는 아무의미가 없음 어차피 block에서 k로 들어가기 때문.
	}
	else {
		(*i)++; // 다음 stepcode에서 while 다음문이 실행되는 것을 막기 위해 i를 1늘려줌
		break; // 반복문 빠져나가기.
	}
}

//////////////////////////////////////////////////////////////////////////////
개선사항을 말하기 전에, 먼저 여기까지를 버전1로 하고 저장해야겠다는 생각이 들었다.
백업도 백업인데, 코드의 데이터화가 어떻게 변화하는지에 대해 지켜볼 수도 있어야 한다는 생각이 들었다.

버전1의 main코드 :
//코드 데이터화
CodeDataization(&ic, "code.txt");

//데이터화한 코드 실행
RunCode(&ic);

//디버그 로그 띄우기
printf("%d %d", ic.data[0], ic.data[2]);

return 0;

버전1의 실험코드 : code.txt
var a;
a = 1;
var b;
var c;
b = 5;
c = b + a;

if(c == 5)
{
	c = c + 1;
}

while(c < 100){
	c = c + 1;
	a = a - 1;
}
//////////////////////////////////////////////////////////////////////////////
버전 1이후의 목표는 아마 
1. 수식과 조건식의 표현이 더욱 자유로워 지는 것일 것이다.
	내가 보기에는 수식과 조건식은 사실상 같은 종류의 식이라고 생각한다.
	왜냐하면 둘다 일정한 값을 반환하고, 수식에 조건식이 조건식에 수식이 쓰일 수 있기 때문이다.
2. 여러가지 자료형이 나타나는 것일 것이다.
	bool, float, double, char등과 그들의 배열이나 포인터를 표현할 수 있는 자료형이 필요하다.
	배열의 자료형은 (배열의 자료형) = (자료형) + (배열) 처럼 정의 된다. 그래서 배열의 자료형이 자료형의 자리에 들어갈 수 있게 해준다.
	포인터의 자료형도 (포인터의 자료형) = (자료형) + (표식) 으로 정의 되었으면 좋겠다.
	그래서 포인터의 포인터나 배열의 포인터같은 것도 하나의 자료형으로 만들어질 수 있는 것이다.
	배열이나 포인터 같은 것을 자료형연산이라 불리게 하고, 다른 자료형 연산이 무엇이 있는가 찾아본다.
		식 : 식이다. 변수의 값에 따라 그 변화가 생긴다. 예를들어 a = c * b + 1; 이라면, 
			c+b+1이라는 식을 저장하다가. a를 get하면, c, b변수에 따라 a의 값이 자동으로 바뀌어지는 것이다. - 유용하지 않을까?
		추상적 자료 : 부모클래스이다. 이를 더 효율적으로 관리할 수 있지 않을까?

그렇기에 개발할 순서를 정하겠다.
1. int형 값과 연산자로만 이루어진 식을 해석하는 함수를 만든다.
	이 기본 연산은 나머지 -> 곱하기 -> 더하기 순으로 연산하고, ()기호는 이 함수를 제귀호출하게끔 만든다.
	ex> 2 + a * (15 + 16); -> 더하기를 건너뛰고 곱하기만 본다. -> a의 값을 가져온다. , ()의 값을 제귀함수호출로 가져온다. -> 곱하기 연산한다. -> 더하기 연산을 찾는다. -> 더하기 연산하여 반환한다.
	그러니 기본적인 알고리즘은 이렇다. (문학적 프로그래밍)
	나머지 연산들 찾아 계산 -> 곱하기 연산 찾아 계산 -> 더하기 연산 찾아 계산
	모든 계산은 num1과 num2, 연산자의 데이터가 필요하고 num1이나 num2가 ()라 바로 데이터가 나오지 않을때 제귀함수를 호출한다.
	모든 계산의 반환값은 num1 <연산자> num2를 식 데이터에서 지우고 그 자리에 반환값 하나만을 넣는다. 
	이는 만들었다. ()와 %, /*-+의 사칙연산과 변수를 끌어오는 것까지 구현했다.
	그러나 (후에 숫자가 같이 텍스트 박스로 저장되어 오류가 발생, 이를 해결했다.
2. 여러가지 자료형을 만든다.
	일단 식에 조건문이 들어가거나 조건문에 식이 들어갈려면 bool 이라는 자료형이 필요하다고 느꼈다.
	때문에 자료형을 먼저 만든다. 만들 자료형은 bool, float, char이다.
	자료형을 만든다는 것은 '값'이라는 것을 다시 정의하게 만든다.
	왜냐하면 실제 변수의 저장공간을 만들때 자료형이 일정해야 만들어질 수 있기 때문이다.
	그렇기 때문에 값을 구조체로 만들 필요가 있다.
	이는 코드 전체가 망가질 수 있는 섬세한 작업이기 때문에 이태까지 한 것을 버전2로 만들고 저장하도록 한다.
	그래서 자료형을 구조체로 만들고 정적변수에 연산자들의 우선순위를 결정했다.
	이를 이용하여 일반식의 % -> */ -> -+를 차례로 했던것들을 
	조건식의 (<>==<=>=!=) -> (&& || !)와 같이 할 수 있도록 일반화했다.
	데이터만 있다면 같은 함수를 호출함으로써 조건식과 수식둘을 처리할 수 있다.
	이 자료형을 만드는 도중 거의 모든 함수의 형태를 바꾸게 되었다.
	그리고 서로 다른 자료형의 값들이 나열되어있는 경우도 생각을 해보았다.
	이를 나는 이렇게 정할 것이다.
	a + 1.0f을 계산하는데, a의 자료형이 int라면, 1.0f를 int로 치환하여 계산하고,
	a + b를 계산하는데, b의 자료형이 float라면 a를 float로 치환하여 계산하는 것이다.
	이러한 방식을 변수우선-후우선형식이라고 하고 네가지 형식을 만들어낼 수 있을 것이다.
	1. 변수우선-후우선 자료형자동변환
	2. 변수우선-전우선 자료형자동변환
	3. 상수우선-후우선 자료형자동변환
	4. 상수우선-전우선 자료형자동변환
	여기중에서 직관적인 것으로 골라 적용시켜야 겠다는 생각을 했다.
	나중에 캐스팅도 만들어질태니 복잡한 연산은 신경쓰지 말자.
	이를 자료형자동변환 방식이라 부를 것이다.
	그리고 이런 기준을 확실히 정하면 조건식과 수식이 식이라는 하나의 개체로 합쳐질 수 있다.

	그러므로 여러 예시를 들어서 이해가 쉽도록 하겠다.
	a = 1 + (23 * (79 % (10/5))); 이 식의 연산과정을 보자.
	식은 GetDataOperation함수를 호출하여 풀어쉽게한다.
	그러므로 이 과정은 GetDataOperation함수의 안에서 일어난다.
	1. 우선순위가 가장 높은 연산자는 %이므로, 식에 %연산자가 있는지 찾는다. 찾았다.
		a = 1 + (23 * (79 % (10/5))) -> %를 연산하려고 한다. num1에 79를, num2에 (10/5)의 결과값을 넣으려한다.
		그렇지만, 아직 10/5를 계산하지 못했다. 
	2. 10/5를 GetDataOperation함수를 이용하여 계산해 식의 공간에 넣는다. (제귀호출)
		a = 1 + (23 * (79 % 2)) -> 이제 num2에 2를 넣고, %를 계산할 수 있게 되었다.
	3. %연산을 계산한다.
		a = 1 + (23 * 1)
		이 식에 더 %연산자가 있는지 탐색한다. 하지만, 없으니 다음 우선순위의 연산(*)을 찾는다.
	4. *연산을 찾았다. num1 = 23, num2 = 1로, 바로 계산가능하다. 계산을 하고 채워넣는다.
		 a = 1 + 23
	5. 이 식에 더 *연산자가 있는지 탐색한다. 하지만, 없으니 다음 우선순위의 연산(+)을 찾는다.
	6. +연산을 찾았다. num1 = 1, num2 = 23로, 바로 계산가능하다. 계산을 하고 채워넣는다.
		a = 24
		GetDataOperation함수는 24를 반환했다.
		a의 데이터공간에 24라는 int형 값(반환값)이 들어갔다.

	이 경우에는 변수의 값도 가져오지 않았고, 다른 자료형의 값들도 연산되지 않았다.
	이번에는 다른 자료형의 값들도 서로 어떻게 연산되는지 한번 예시를 들어보겠다.
	a = (value / max) * 165
	이 식은 일정 길이를 일정 비율로 쪼갠값을 a에 저장하는 식이다. 
	a는 int형, value는 float형, max는 int형
	값을 정의하면, value = 50.f, max = 100
	그러면 a는 즉, 165길이의 50%의 길이가 얼마만큼인지 int형으로 나타내라는 식의 결과값이 된다.
	먼저, 변수우선-후우선 자료형자동변환 방식으로 이를 전개하겠다.
	1. 우선순위가 가장 높은 연산자는 %이므로 %를 찾아보았지만, 없다. 그다음은 *이다. 찾아보았더니 있다.
		(value / max) * 165 
		num2에는 165가 들어가지만, num1에는 뭐가들어가는지 모른다. 따라서 GetDataOperation함수를 호출하여 (value / max)를 계산하려 한다.
	2. 2번째 GetDataOperation함수의 안이다. 여기에서 전체식은 (value / max)이다.
		우선순위가 가장 높은 연산자는 %이므로 %를 찾아보았지만, 없다. 그다음은 *이다. 찾아보았더니 없다.
		그다음 우선순위는 /이다. /를 찾아보았더니 있다. 
		계산하기 전에 우선 변수우선이다. 변수의 자료형이 상수의 자료형보다 더 우선된다. 그러나 둘다 변수기 때문에 우선이 없다.
		두번째는 후우선이다. 그래서 후수인 max의 자료형을 찾아봤더니 int이다.
		그렇기 때문에 연산을 하기 위해 value의 값이 int형으로 바뀐다.
		나누기 연산을 한다. 50 / 100 => 0
		0을 반환한다.
	3. 두번째 함수에서 반환했으니 이제 첫번째 함수의 차례다. (value / max)의 반환값은 0이다. 고로, num1에는 0이, num2에는 165가 들어간다.
		둘다 int이니 그냥 계산을 하면 된다.
		0 * 165 = 0;
	4. 첫번째 함수가 0으로 반환되어 a에는 0이 들어간다.
	-> 이 과정에서, 우리는 식은 맞을지 모르지만, 결과가 우리가 원하는 결과가 아니었음을 깨닺는다.
	-> a는 82여야 하는데, 0이 되어버렸다.

	이번에는 변수우선-전우선으로 계산하자.
	1. 우선순위가 가장 높은 연산자는 %이므로 %를 찾아보았지만, 없다. 그다음은 *이다. 찾아보았더니 있다.
		(value / max) * 165 
		num2에는 165가 들어가지만, num1에는 뭐가들어가는지 모른다. 따라서 GetDataOperation함수를 호출하여 (value / max)를 계산하려 한다.
	2. 2번째 GetDataOperation함수의 안이다. 여기에서 전체식은 (value / max)이다.
		우선순위가 가장 높은 연산자는 %이므로 %를 찾아보았지만, 없다. 그다음은 *이다. 찾아보았더니 없다.
		그다음 우선순위는 /이다. /를 찾아보았더니 있다. 
		계산하기 전에 우선 변수우선이다. 변수의 자료형이 상수의 자료형보다 더 우선된다. 그러나 둘다 변수기 때문에 우선이 없다.
		두번째는 전우선이다. 그래서 후수인 value의 자료형을 찾아봤더니 float이다.
		그렇기 때문에 연산을 하기 위해 max의 값이 float형으로 바뀐다.
		나누기 연산을 한다. 50.f / 100.f => 0.5f
		0.5f을 반환한다.
	3. 두번째 함수에서 반환했으니 이제 첫번째 함수의 차례다. (value / max)의 반환값은 0.5f이다. 고로, num1에는 0.5f이, num2에는 165가 들어간다.
		둘다 상수이고, 전우선이니, 둘다 float가 된다.
		0.5f * 165 = 82.5f;
	4. 첫번째 함수가 82.5f으로 반환되어 a의 자료형이 int이므로, int로 형변환을 해준다. a에는 82가 들어간다.
	-> 이 과정또한, 정상적으로 보이지만, a의 자료형으로 바꾸어주는 장치가 없었다면 잘못된 값이 들어갔을 것이다.
	-> 하지만, 정상적으로 들어갔다.

	만약 상수우선이라면 어떤가?
	물론 첫번째 연산에서 둘다 상수가 되었지만, 그게 아니었다면, 이 식은 절대 82가 되지않는다. 0만이 있을뿐이다.
	만약 (value/max)를 먼저 계산하고 변수에 저장한뒤 식에 변수를 넣는다면?
	바로 0이 나오게 될 것이다.
	
	이 설명은 우선순위가 식에 혹은 코딩에 얼마나지대한 영향을 끼치는지를 실감시키기 위해 만들었다.
	그렇기 때문에 이 자료형의 변환문제는 신중하게 결정해야 한다.
	때문에 이것을 결정하기위해 해야할 일은 다음과 같다.
	1. C언어나 다른 언어는 어떻게 동작하는지 확인하기
	2. 가장직관적인것이 무엇인지 찾기

	1. C언어는 자료형에 우선순위가 붙어있는 경우라 위 4가지 경우가 모두 아님. 깔끔하나 일관성이 없다.
	2. C#은 그냥 정석대로 자료형이 다르면 오류를 내보낸다. 그래서 그냥 보면 코드가 좀 더럽다.
	그래서 나는 C#의 방식이 더 좋다고 생각했다.

2020 - 11 - 26일
그래서 이 다른 자료형을 구현하기 위해 템플릿도 시도해보았지만, 여러 한계때문에 적용시키지 못했다.
	그 이유는, 
	1. 임의의 클래스를 넣기가 어려워진다. 템플릿의 타입은 클래스가 아닌것도 취급이 가능해야하기 때문에 발생한 문제다.
		멤버함수, 변수를 호출 할 수 없다. - 여기서 사실상 끝이다.
	2. 자료형이 변수화가 되어있지 않아, 변경이 용이하지 못하다.

	그래서 그냥, returnType과 ValuePtr만으로 그것을 구현해내고 있다.
	여러 오류들을 고치고, 이제 디버깅 중이다.
	디버깅 결과 모든 변수를 int형으로 하고 계산을 했을때, 훌룡하게 계산을 하였다.
	그러나 조건문이 나오고나서 오류가 생겼다. typestring을 "Int"로 해놓은 탓이다.
	여기에서 나는 조건문을 해석하는 함수도 그냥 식을 해석하는 함수와 합쳐줬으면 좋겠다.
	그러기 위해서 각 자료형의 연산자의 표현과 연산함수의 모양을 바꿔야 하겠다.
	연산자의 표현 - 이 연산자가 어떻게 쓰이는지에 대한 원형 - 자료형과 연산자의 위치정보, 리턴자료형 정보

	그러기 위해 필요한 것은,
	1. bool 자료형의 선언
	2. 연산자 클래스 선언
	3. 연산자 함수 변경

	이걸하기 전에 코드가 꼬일 수도 있으니 미리 버전 3으로 백업해놓자.
	백업했다.

	그리고 고민이 생겼는데,
	만약 연산자 클래스를 만든다면, 이 연산자들을 어디에 어떻게 저장해야 하느냐에 문제다.
	기존에는 자료형클래스 안에 연산자를 저장했지만, 만약 조건연산자 같은 경우는 리턴과 피연산자의 자료형이 달라서 
	어떤 클래스에 저장해야하는지 혼동되는 경우가 있다.
	그래서 연산자풀을 만들기로 했다.

	다 만듬...

이제 구조체나 클래스를 만들 차례이다. 먼저 만든 것을 버전 5로 백업하고 다시 어떻게 만들지를 생각한다.

먼저 그 내부구조를 설계하기 전에 "구조체 생성 코드"를 만들어야 한다. 그리고 그것을 다른 함수에서 어떻게 처리할지 결정해야 할 것 같다.

코드의 종류를 만드는 데 필요한 과정은 이렇다.
1. enum class codeKind에서 새로운 항목을 만든다.
2. AddCodeFromBlockData함수에서 해당 종류의 코드가 생성되는 조건을 정하고 if문으로 만든다.
3. 조건에 부합하면, codeBlock을 만들고, 그 구성을 어떻게 할지 정한다. 

일단 구조체를 만들고 있는 과정속에 있다. 구조체 데이터와 그것에 대입하는 방식을 만들었다.
이제 식 속에서 구조체안의 맴버함수를 찾아가는 "." 을 사용할 수 있게 해야 할 차례다. 
getvaluewithString 이 함수가 문자열을 실제 값이나 연산자에 대응시켜주는 함수이다. 이를 바꿔야 할 듯 하다.
또한 Excute_Function에서도 ","를 기준으로 문자열을 잘라내어 GetDataOperation함수로 하나의 값으로 변환을 하는데, 결국에는 바꿔야 할 함수가 GetDataOperation함수 내부임을 알 수 있다.

여기에서 떠오르는 방법은 
1. GetDataOperation함수에서 "."을 하나의 연산자로써 작용하게 하는 것이다. - 가능한가?
 - 이걸 할려면 일단 연산자에서 "." 의 코드를 따로 분리해서 작용시켜야 해서 더 복잡해지고 더러워진다.
2. GetDataOperation함수 가장 첫번째 부분의 작업으로 "."이 달린 것들을 상수로 치환시키는 것이다.
 - 하지만 이 2번째 방법으로 결정한다면 해결해야 될 문제가 있는데, 만약 하나의 상수로 표현이 불가능하다면 어떻게 할지에 대한 것이다.  
 - 지금 이 문제에 대한 두가지 방법을 생각하고 있는데, 
	1. "{1, "name"}" - 이렇게 스트링으로 표현해서 연산 - 이 방법을 선택함. 왜냐하면 2번은 너무나 많은 코드를 바꾸어야하는 문제점과, 문자식을 해석하고 계산해야 한다는 불편함이 있기 때문
	2. 모든 연산자나 상수를 스트링으로 표현한것을 다른 것으로 바꾸자. (Ptr?)

일단 2-1번으로 문제를 해결하고 코드를 정상적으로 실행시켰다.
다음은 오류코드를 만드는 것을 생각하고싶다.

오류 코드가 있는 이유는 실행하기에 적합하지 않은 코드가 들어가 있는 경우, 그 코드의 위치를 출력하고 설명을 달아 사용자에게 해당 코드를 수정하도록 요청하기 위한 것이다.
그렇기 때문에 "어떨때 실행에 적합하지 않은지"와 "어떻게 출력해야 할지"를 고민해야 한다.

그려려면 일단 실행에 적합하지 않은 곳을 찾을 필요가 있다. 인사이드 코드도 하나의 프로그램이기 때문에 그 프로세스가 있고, 각 프로세스마다 에러코드가 있을 것이기 때문에 각각의 과정을 탑색하자.

다음은 현재 인사이드 코드의 실행과정이다.
1. 기본 자료형 정의
2. 기본 연산자 정의
3. 코드 데이터화
	1. code.txt 에서 문자열을 모두 복사
		복사과정에서 오류가 생기면 오류를 발생
	2. textblock을 구성
		textblock을 구성하는 과정에서 뭔가 이상한 문자열이 발생되었을때 오류를 발생
	3. "struct scan"모드로 struct 관련 코드들을 추출
		구조체의 맴버변수 정의 코드가 잘못되었을때 오류를 발생
	4. 구조체 정의
		구조체 이름이 중복되는 경우 오류를 발생
	5. "none"모드로 보통의 코드들을 추출
		코드가 잘못되어 정의되지 못할때 오류를 발생시키자.
4. 함수 스캔
	1. 함수이름이 키워드이거나 이름이 같은 함수가 있을때 오류 생성
	2. 반환형식 자료형의 이름이 정의되지 않은 자료형일때 오류 생성
	3. 함수이름이 "main"이라면 첫번째 프로세스로 저장되는데, main함수가 생성되지 않았으면 오류를 생성
5. 프로세스에서 가장 위의 코드플레이데이터(cpd) 가져오기
6. cpd를 실행
	1. 반복
		코드실행
			ck_addVariable
				: code의 blockdata가 2개 이상이면 약간의 의심의 메시지를 날린다.
				: AddVariableCore 함수에서 typename이 없는 자료형의 이름이거나 name이 키워드나 이미 있는 이름일 경우에 변수 선언에 실패하고 오류메시지를 반환한다.
			ck_setVariable
				: 변수 t, e가 있는데 t는 r-value, e는 l-value의 수식을 의미한다. 여기에서 t나 e가 한 변수의 이름에 성립하지 못하거나 변수들의 조합이 r, l이 아닐경우 오류를 표시한다.
				: "x"를 찾을 수 없습니다. 이런 식으로 하면 될듯
				: GetDataOperation - 이 함수를 호출하게 됨 이건 따로 하자.
			ck_if
				: GetDataOperation - 이 함수를 호출하게 됨 이건 따로 하자.
			ck_while
				: GetDataOperation - 이 함수를 호출하게 됨 이건 따로 하자.
			ck_useFunction
				: 함수 이름에 맞는 함수가 없을때 오류를 반환
				: 함수의 파라미터 개수와 입력된 파라미터의 개수가 차이가 날때 오류를 반환
			ck_returnInFunction
				: GetDataOperation 으로 나온 리턴 값이 해당 자료형과 일치하지 않을때 오류를 반환함.
			ck_blocks
				: ?
		만약 return으로 v가 nullptr이 아니라면 v를 return함.

대충 이런식으로 나중에 더 추가하면 될 것 같다. 그 과정에서 코드를 생성하는 부분도 일정한 공식에 맟추어 조건을 절대적으로 부여해야 할 것이다.

그려려면 일단 코드의 공식을 확실하게 만들어야 한다.
일단 코드의 공식을 몰라도 할 수 있는 오류들을 만들자.

일단 만든 오류들은 다음과 같다.
[ERROR] : 첫번째로 실행되는 함수가 지정되지 않았습니다.
[ERROR] : 변수 %s 가 정의되지 않았습니다.
[ERROR] : 구조체 %s 의 맴버변수 %s 가 정의되지 않았습니다.
[ERROR] : 값이 할당되지 않았거나 타입이 같지 않아 복사에 실패했습니다.
[ERROR] : codeKind가 정해지지 않았습니다. 비정상적인 코드를 해석하려 했습니다.
[ERROR] : %s 함수호출에 너무 많은 파라미터가 입력되어 일부가 제외되었습니다.
[ERROR] : %s 함수가 정의되지 않았습니다.
[ERROR] : %s 파일을 불러오는데 오류가 발생했습니다.
[ERROR] : %s 구조체가 정의되지 않았습니다.

일단 이렇게 하고 여러 알고리즘을 구현하면서 오류 없는지 찾는데 최선일듯.
그리고 오류가 잘 출력되는지도 확인

그렇게 생각하고 있었는데, 음.. 여러 알고리즘을 쓰려면 일단 배열이 있어야 할듯.
배열을 구현해야 겠다.
<배열 공식>
type[num] variable;
variable[i] = value;
variable = (type[num])value;

근데 이걸 배열자체를 포인터로 해야할지 값으로 해야할지 모르겠다.
나는 값으로 하는 게 좋다고 생각하는데 뭔가 표준이 포인터임.

아니면 배열을 아예 정적메모리 할당이 아니라 동적 메모리 할당으로 할까 생각중
type[] 이런 식으로 정해진 숫자가 있는 것이 아니라 그냥 
일단 이것도 생각해야 하지만, 
오류가 나타나는 코드의 위치도 특정할 수 있어야 함.
근데 이게 줄을 보기는 어렵기도 하고 
아마 어떤 함수에서, 어떤 몇번째 코드에서 오류 났다고 해야할듯.
호출스택도 보여주면 더 좋고

일단 완성
void PrintCodeLocation(CodePlayData* cpd)을 이용해 코드의 위치를 특정하여 오류를 나타낼 수 있다.

배열을 만들고, 포인터를 만들어야 하는데 이것들은 기존 자료형에 연산자처럼 덧붙여서 새로운 자료형을 만드는 방식이다. 그걸 만들어야 될것 같다.
(type)(typeOperation) => (new type)
그래서 int***[]**[][] 같은 타입도 정의가능하게끔 해야한다.
일단 백업하자.

버전 6를 저장했다. 
이전 버전에서 struct를 만드는 과정에서 ValuePtr의 type_name변수와 Struct의 Type_name변수의 차이를 두어서 저장했었다. type_name은 이 값이 어떤 종류의 자료형으로 해석되어야 하는지에 대한 정보였고, Type_name은 실제 구조체의 이름이었다.
이 형식에서 포인터와 배열을 만들어야 해서 이 형식에 대해 고민을 할 필요가 있다. 
포인터와 배열같은 자료형 연산자들은 보통 3가지 정보가 필요하다고 본다.
1. 연산하기 전의 자료형의 정보 - 2번을 할때 필요
2. 그 쟈료형을 어떻게 변형시킬건지에 대한 정보 - 이걸 하기 위해 만드는거임
3. 연산 후의 자료형의 식별자 정보. - 연산 후에 또 연산하는 것을 대비하는데 필요함

근데 일단 포인터를 저장하려면 메모리번지를 설정할 수 있어야 하고 그려려면 메모리 공간을 따로 만들 필요가 있다.
data : 전역변수 저장
stack : 함수안의 지역변수 저장
heap : 동적인 메모리 할당을 하는 변수 저장

그런데 포인터는 int형으로만 저장된다 따라서 코드를 실행하기전에, 메모리를 얼마나 사용하고 각 메모리 부분이 차지하는 범위는 얼마나 되는지 지정하게 해야한다. 

변수가 새로 생길때마다 새로운 주소에 할당되고, 삭제되는 변수는 주소에서 사라진다. 사라진 주소는 공백으로 남지만, 더이상 새로운 주소가 없을때 다시 돌아와 매꿀 수 있다.
int n = (flow <= max) ? flow : flow - max; // 이런 식으로.
그러면 n으로 주소를 할당하면 됨
그렇게 만들었다.
이전버전에서는 전역변수가 없었다. 왜냐하면 함수를 넣는 과정에서 지역변수만 고려하도록 했고, 함수안에서만 변수가 만들어지도록 했기 때문이다. 하지만, global 메모리가 생겨서, 전역변수도 만들어야 겠다.
만들려고 했는데 코드가 만들어지는 명확한 기준이 없어서 이것을 명확히 해야겠다.
이걸 배열로 만들 수 있다면 그렇게 하고 싶다.

일단 메모리 작업은 끝났다 생각보다는 오래걸림
이제 포인터, 배열과 같은 자료형연산을 어떻게 표현할 것인가 고민해보자.

고민 끝에 결국은 정확한 공식이 필요하다는 것을 알았다. 명확한 공식은 나에게 명확한 알고리즘을 제시해줄 것이다. 

그래서 포인터를 만들려면 우선 변수선언의 공식을 다듬어야 한다.

<자료형> <변수이름>;
이것이 기존 공식이다.
<자료형> <자료형 연산자> => <자료형>
이 되도록 해야한다.

하지만 지금은 미리 자료형을 정리해둔후 대응되는 문자열을 발견하면 그 자료형으로 값을 치환하는 식이다. 이것을 어떻게 하면 자료형 연산자의 의미를 줄 수 있는가?

자료형 연산자를 쓸 수 없는 이유는 자료형들이 정해져 있는 상태이기 때문이다.

일단 해보고 있는 방법은 type과 subtype을 구분하는 것이다. 
만약 
int*[4] a; 라는 코드가 있으면 
name : a // 마지막 블록
type : [4] // a 이전의 블록

subtype : int* // 나머지
이렇게 해서 변수를 만들때 이 세가지를 입력받게 하는 방식으로 갈 것 같다.
가끔 이렇게 뭔가를 많이 고칠때면 어떤 걸해야할지 모르는 경우가 있다. 그럴때는 그냥 디버깅 하자.

일단 이렇게 해서 포인터 변수를 만드는 것 까지는 되었다. 하지만 포인터 변수를 쓰는 과정에서 사용되는 연산자 *, &같은 연산자들을 처리하기 위해 새로운 종류의 연산자를 만들어야 겠다고 생각했다.
전위연산자라고 부르고 싶다.

기존 연산자는 이런 형태이다.
form, name, paramTypes[2], returnType
전위 연산자는 모두 같지만, paramType[0]이 ""이라는 차이점이 있을 것이고, 이는 고정되어야 한다.

연산자를 만들고,
GetDataOperation함수에서 이를 처리하게끔 해야한다.

근데 문제가 생겼다. 뭐냐면 연산자에는 보통 ValuePtr2개가 들어가는데, 이는 주소값에 대한 데이터를 포함하고 있지 않다. 따라서 주소값을 얻으려면 메모리로 가서 직접 찾아야 한다. 하지만, 그 코드가 코드가 실행중일때 실행되서 오래걸리는 것이 좀 걸린다.
내가 생각한 해결책은 2가지이다.
1. ValuePtr에 주소값에 대한 데이터를 넣는다?
	만약 1번으로 한다면 모든 값에는 주소가 필요하다. 왜냐하면 &2, &3같은 식도 성립해야 하기 때문이다. - 애초에 컴퓨터가 이미 그렇게 하고있긴 하다
	그리고 사용하는 메모리가 훨씬 많아진다. 모든 값에 값이 하나 더 들어가는 것이니, (사용하는변수 개수) * 4byte 씩 더 들어간다. 이는 변수가 1000개면 4000byte를 잡아먹는 다는 것이다.
2. 주소값을 받는 연산자의 종류를 만든다?
	일단 이게 가능할지는 잘 모르겠다. 왜냐하면 피연산자로 값을 받지않으면 그것이 연산자인가? 싶기도 하고, 과정이 머릿속에 잘 그려지지 않는다.
	
생각난 방법이 있다. 
구조체를 만들때 . 을 어떻게 처리해야 할지 몰라서 해맨적이 있었는데, 제일 처음에 자체적으로 처리를 해줌으로써 해결했다. 아마 &도 그렇게 할 수 있지 않을까 생각한다.

그래서 GetDataOperation의 구조가 또 한번 바뀌었다.
1. 문자열들을 선연산 후 문자열로 변환
2. 기존의 식 해석.

그래서 기존에 있던 "."연산코드도 바꿔야 할 필요가 있었다. 왜냐하면 기존에는 값을 스트링으로 바꿔서 표현식에서 대체하도록 하는 코드였기 때문에 값이 아니라 메모리를 스트링으로 표현하도록 해야한다.
"{loc=125}" 이런식으로 표현하고자 한다. 이는 125번지에 있는 메모리를 뜻한다.
이는 "{ptr : 125}"표시와 엄연히 다르다. ptr은 포인터 변수의 값을 나타내기 때문이다.단지 메모리의 주소값을 가리킬뿐이다. 하지만 loc은 그 변수자체를 뜻한다. 고로 일반 연산자 처리를 하기 전에 이것은 모두 정리되어야 한다. 일반 연산자는 오직 상수로 나타낼 수 있는 것만을 처리하기 때문이다.

그렇게 해서 주소값을 반환하는 &연산자도 만들었다.
이제 추가할 것들은 
1. ->, *연산자 추가
2. 배열추가
3. preType의 처리
이렇게만 하면 포인터와 변수는 끝나는 것 같다.
근데 특히 3번을 어떻게 해야 할지 모르겠다.
3번을 할 수 있어야 
int[]*[][]* 같은 자료형도 만들 수 있는 건데,,

*연산자를 추가하는 과정에서 여러가지 고민이 있었는데, 그것은 이런것이었다.
*ptr.x = 0; 이런 코드는 어떻게 처리해야 하는가에 대한 고민이였는데, 
보통 c언어에서도 이는 실행되지 않는 코드라는 것을 알아내었다.
그래서 연산자들의 우선순위를 명확하게 할 필요가 있다.
1. ()
2. []
3. -> .
4. & *
5. 일반 계산

(*ptr).x = 2;
이 식은 
1. {loc : 15}.x = 2;
2. {loc : 16} = 2;
이렇게 해석되어야 한다.

고로 괄호가 먼저 해석되므로 이러한 선연산자 함수들은 제귀적으로 호출될 수 있어야 한다.
예를 들어
함수호출 (*ptr).x = 2;
함수호출 *ptr
=> 결과 {loc : 15}
=> 결과 {loc : 16} = 2; 

보통 하나의 식은 
A = B 같은 형태로 전달되는데, 
A와 B가 뜻하는 바가 서로 다르다. A는 변수 자체를, B는 값을 나타내기 때문이다.
그래서 C언어에서도 l-value, r-value를 나누었다.
고로 ValuePtr을 반환하는 r-value용 수식해석함수와
int를 반환하는 l-value용 수식해석함수가 따로 있어야 한다.

r-value용 수식해석함수는 이미 있다. GetDataOperation.
이 문서에서 정말 많은 이야기를 해왔다.
이것을 배껴서 변형시켜서 l-value용 수식해석함수를 만들어야 한다.

그래서 선연산을 하는 코드를 바꿀 필요가 있어 보인다. 좀더 수식에 가깝게 해석하는 것이다.
(이제까지는 모든 expression을 대상으로 한번에 선연산을 진행해 왔는데, 블록하나하나를 고려해서 해석해야 한다.)
또한 선연산을 하는 도중에도 괄호의 역할을 구분하는 것이 중요하다. 이 괄호가 그냥 값을 반환하는 건지, 아니면 변수자체를 반환하는 건지 알 수 있는 근거가 필요하다.
예를 들어 
(*ptr).x[(func(2, 5) - 1) * 5] = 2; 이런 식이 있다면 첫번째 괄호의 목적은 변수 자체를 반환하는 것이다. 왜냐하면 괄호끝 바로 앞에 "." 연산자가 있기 때문이다.
그러나 두번째 괄호는 값을 반환하는 역할을 가지고 있다. 왜냐하면 func(2, 5)-1이란 내용은 절대 변수자체가 될 수 없고, [] 안이기 때문에 필요한 것은 변수자체에 대한 정보보다 
그저 값이 필요했기 때문이다. 이러한 기준도 어떻게 정해야 할지를 생각해보아야 한다.
무조건 []안의 괄호가 값을 반환하는 것은 또 아닐 것이다. 왜냐하면 괄호가 변수자체의 정보를 가져옴으로써 얻을 수 있는 값도 존재하기 때문이다.
지금 이렇게 봤을때는
변수 자체를 원할때 값을 주면 에러가 나고,
값을 원할때 변수를 주면 에러가 나지 않지만, 그 내부 내용에 따라 변수자체가 존재하지 않을 수 있다.
그래서 값을 원할때는 변수가 존재하면 변수를 주고, 존재하지 않으면 값을 주어야 한다.
변수는 값으로 변할 수 있지만, 값은 변수로 변환이 불가능하기 때문인 요인도 있기 때문이다.

만약 변수를 원할때 내용에 변수를 반환할 수 없다면 오류를 발생시켜야 한다.

정리하면
want	can  	give	react
변수	변수, 값	변수	정상
변수	값	값	에러
값	변수, 값	변수	정상
값	값	값	정상
다음과 같다. 
want는 원하는 것
can은 전달할 수 있는 것.
give 전달할거
react는 그로인해 생겨날 반응이다.

그렇다면 변수를 원하는지, 값을 원하는지는 어떻게 정할까?
생각나는건 이정도이다.
1. ".", "->"연산자 앞은 변수를 원해야 함.
2. [] 왼쪽은 변수를 원해야 하고, 안쪽은 값을 원해야 함.
3. & *은, 앞에 값이나 변수가 아니거나 연산자이거나, 앞이 없을때, 이 연산자들 뒤에는 변수를 원해야 한다.
4. 그 이외에는 값을 원해야 함.
일단 이렇게 정하고 코딩을 시작해보자.

그래서 변수의 메모리 주소를 리턴하는 GetDataFrontOperation 함수를 만들었다.
여기에서 해주어야 할 역할은 다음과 같다.
1. 변수를 리턴할 수 있는지 검사해야 한다. - 검사 방법이 없고 직접 해보고 뭐가 나오는지 보는 수밖에 없음.
2. 식을 변수로 바꿔줘야 한다.
3. 만약 변수를 리턴할 수 없다면 값을 전달해주어야 한다.
왜냐하면 ()를 처리하려면 일단 변수반환이 가능한지 알아야 하고 알 수 있는 방법은 GetDataFrontOperation함수일 뿐이므로
어떠한 판단과정 없이 바로 그 함수를 호출해야 하고, 고로 만약 변수를 리턴할수 없을때는, 이 함수가 값을 리턴해야 하기 때문이다.
물론 함수밖을 빠져나가서 뭔가를 할 수도 있겠지만, 함수 안에서 하는 것이 좋다고 생각했다.
그 이유는 다음과 같다.

1. 보통 코딩을 하는 사람이 ()를 보면 이 괄호는 똑같은 역할을 한다고 생각하기 때문이다. 사실 다르지만, 그 두가지의 역할은 서로가 연관이 되지 않지도 않다.
	그래서 가급적 하나의 함수에 내용을 담는 것이 합당하다고 생각했다.
2. 이 괄호는 모든 식에 들어가다 보니 정말 많은 곳에 많이 제귀적으로 쓰인다. 때로는 그냥 Operation함수에서 FrontOperation함수를 호출하는 경우도 있다.
	만약 괄호를 처리하는 데에 이 함수를 연관시키지 않는다면, 이런 제귀적 호출이 필요해 코드가 더러워질 것 같았다.

배열되어있나?
배열되어있으면 바로 할 수 있긴함.

배열 문법
int[4] a; - 이러면 배열 생성됨.
이렇게 만들려고 봤는데 AddValue 에서 약간 어떻게 해야 될지 모르겠다.
그래서 원래는 a라는 포인터를 만들고, 그 a의 값이 주소값이 위치부터 4만큼 메모리를 할당시켜라.. 라는 의미인데..
그렇게 하면 되지 않을까? 좀 무린가
근데 그걸떠나서 preTypename이 좀 걸리는게 가장 간단하긴 한데 이걸 어떻게 해석해야 할지 감이 안온다.

int[4] 	: a 포인터 a를 만들고, a의 포인터값을 주소값으로 가지는 int형 변수 이후에 3개를 더 만들어라.
(ptr)[n] 	: 포인터의 주소값으로 가지는 메모리에서 n번 더 가면 나오는 메모리

1. pretype이나 type을 string으로 한 이유를 찾는다. - 기록문서에서 찾아볼 수 없었고, code에서도 pretype은 쓰이지 않았다.
2. typestring만 보고 실제 그 타입의 ValuePtr을 반환할 수 있는 함수를 만든다.

그 전에 게속 고치기로 했다.
일단 AddValue에서 siz값을 받아야 하니까 AddVariable함수내의 GetDataAddVariableTexts함수를 통해 얻고, 
AddVariableCore - AddValue에 적용시킨다.
그렇게 할려고 했는데, 뭔가 함수내에서 메모리에 상관을한다는 것이 일반적이지 않았다.
메모리는 Memory::AddDataToMemory에서 주로 다루고 있었다. 이 함수는 AddVariableCore에서 사용되었다.
결국 원래는 값을 만들고 그것을 메모리에 저장하는 방식이였다면,
배열의 값은 포인터와 관련이 있기 때문에 어디에서 작업을 해야 마땅한지 잘 모르겠다.

내가 원하는 그림은 이렇다.
AddValue{
	만약 array라면
		AddVariableCore로 변수메모리에 저장
			 - 이 과정에서 typestring을 진짜 값으로 바꾸는 함수가 필요함.
		그 중 첫번째 메모리의 주소를 array포인터에 저장
			 - 이 때문에 AddVariableCore 함수가 주소를 반환할 필요가 있어짐.
		array 사이즈 지정
		반환
} // 결론은 메모리가 할당되지 않은 배열포인터값을 반환. - 배열의 요소들의 주소는 있음.

일단 이렇게 구현했다.
다음은 a[1] 이런 것을 구현해야 한다.
일단 선연산처리를 해야 할 것 같다.

일단 모든 선연산 처리가 끝났다. 테스트를 해보면 될 것 같다.
테스트 결과 naming에 배열의 각 항목들이 이름이 없는 상태로 나열되어있어 이것을 없애야 하고, 
배열이 2개부분에서 같은 이름으로 naming되는 것을 확인했다. 왜 2개가 되는지 봐야 되겠다.
보니까 while문에서 다음코드로 넘어가지 않고, main의 맨 첫번째 코드로 넘어가는데..?
while이 잘못된 것 같다. 물론 항목들의 naming은 좀 고쳐야 되겠다.

일단 테스트를 모두 마쳤고, 배열도 작동되는 것을 확인했다.
하지만, 그 과정에서 기존에 썼던 코드들과 새로운 코드들이 충돌하는 경우가 정말 많았고, 
이것이 더 있을 것 같다. 그래서 지금부터는 여러 알고리즘으로 테스트를 하며 오류를 잡고, 
법칙을 정해야 한다. - 근데 자료형을 조합하는걸 안만들어서.. 좀 그렇긴 한데.. 그것도 만들어야 하나?

일단 테스트를 할 코드는 "윤성우 열혈 C 프로그래밍"에서 가져온다.


만약 테스트가 끝나면 여러가지 기능을 넣고싶다.
이러한 추가적인 기능들은 이 프로그램에서 플러그인처럼 넣었다 뺐다 할 수 있어야 할 것 같다.
1. NamingSeeker : 스트링으로 블록을 불러올 수 있는 함수. NameSeekType("int") 라고 쓰면 그 블록이 int가 되는 것. Type뿐아니라 변수, 함수, 연산자등에도 쓰일 수 있다.
ex>
char[10] typen = "float";
NameSeekType(typen) fv = 10.05;
output("%v", fv);
>> 10.05

2. any type : 이 타입은 아무타입의 변수가 들어가도 수용할 수 있게 되는 변수이다. 변수를 선언할때는 auto처럼, 함수의 매개변수로 들어갈때는 어떤 변수든 다 들어갈 수 있다. 구조체의 맴버변수로 들어갈때, 포인터형식으로 넣는 것이 가능하도록 한다.(void*)느낌
그리고 any로 선언을 한 후, int형 변수가 자리를 차지했다면, float형 값을 그 변수에 넣어도 잘 들어간다.
ex>
any num1 = 10;
any Addfunc(any n, any, m){}
struct AA{
	any* m;
}
/////

3. Interprete
txt로 작성된 코드를 인터프리터가 읽어들일때, Interprete("code2.txt"); 
이렇게 하면 해당 코드조각이 실행된다. 원래의 InsideCode기준으로..
하지만, 다른 위치에 이 Interprete함수를 설치하거나 삭제 할수 있게하면 더 좋을 것 같다.

4. CodeBlocks
코드를 하나의 키워드로 압축가능하다.
ex>
CodeBlocks returnZero {return 0;}
>>앞으로 returnZero; 라는 코드를 쓰면 return 0;으로 치환된다.

이는 함수와는 다르게 코드텍스트 자체를 붙여넣는 것이라 (헤더파일과 같이)
만약 코드블록에 저장된 텍스트들에서 선언되지 않았던 변수명이 나오면 실행할때 오류를 발생시킨다.
어떤 텍스트든 코드블록을 선언할 수 있다.

코드블록은 string[] 타입으로 치환가능하고, string[]타입의 변수는 코드블록으로 치환가능하다.
CodeBlocks int_a_b {
	int a;
	int b;
}

(string[])int_a_b == {"int", "a", ";", "int", "b", ";"}
이런 상태가 된다. 이를 통해 코드블록을 변경가능하다.

그리고 코드블록은 그들만의 연산이 가능한데, 
cb1 + cb2 => 코드를 cb1을 실행하고, 그다음 cb2를 실행하는 코드블록을 반환
cb * n[i] => cb 를 n번 반복하는 반복문을 씌운다. 반복자는 i를 사용한다.
cb # ("==", ">") -> cb 내의 ==를 모두 >로 바꾼다.
등등 많이 있으면 좋겠다. - 사실 프로그래머가 직접 함수로 만들어도 된다.

코드블록을 실행시킬려면, 이렇게 하면 된다.
cb;
아무것도 넣지 않고, 이것만 넣으면 실행된다.

5. 함수변형(Function Modify)
기존의 함수의 내부내용에 무언가를 추가하여 함수를 변형할 수 있다.
ex>
int div(int a, int b){
	return a/b;
}

div(10, 0) [0 : { if(b == 0) {output("0으로 나눌 수 없습니다."); return 0;}}];
>>div 내용 0번째 줄에 다음 내용을 추가해 실행하라.
int div(int a, int b){
	if(b == 0){
		output("0으로 나눌 수 없습니다.");
		return 0;
	}
	return a/b;
}

이는 코드블록을 사용해 다음과 같이 나타낼 수 있다.
CodeBlocks If_Zero_Then_Error {
	if(b == 0){
		output("0으로 나눌 수 없습니다.");
		return 0;
	}
}

div(10, 0) [0 : If_Zero_Then_Error];