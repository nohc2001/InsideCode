version 0.2 목표
1. exenum 이 1이 아니면 제대로 실행이 안되는 오류. -> 완료
2. half jit 만들기
3. 힙 메모리 연산 만들기
4. Single Instruction Multiple Thread 만들기
5. 많이 보이는 명령 패턴 요약하기

1. a = a + b;
2569    :AXBY(52)
2570    :POP_AB(218)
2571    :AU_UINT_MUL_B(92)
> A <- A*B
-> 완료

2. variable.member, variable[constindex], variable[varindex]
A=&VID 68;
PUSH_B_CONST_4 10;
AU_UINT_ADD_A
> A<=(&vid+const) 68, 10;
-> 완료

A=&VID 68;
B=&VID 8;
B=*B;
A = A+B;
> A<=(&vid+vid) 68, 10;

3. variable = <expression>
// A에 어떤 값을 담음.
892     :A=&VID(195) > 68(68, 0, 0, 0)
897     :LA=A(199)
898     :*LA=*A_N(224) > 12(12, 0, 0, 0)

892     :A=&VID(195) > 68(68, 0, 0, 0)
897     :LA=A(199)
898     :*LA=*A_4(224) > 12(12, 0, 0, 0)

892     :A=&VID(195) > 68(68, 0, 0, 0)
897     :LA=A(199)
898     :*LA=*A_2(224) > 12(12, 0, 0, 0)

892     :A=&VID(195) > 68(68, 0, 0, 0)
897     :LA=A(199)
898     :*LA=*A_1(224) > 12(12, 0, 0, 0)

        :A=&Global_VID(178) > 0(0, 0, 0, 0)
16      :LA=A(161)
17      :*LA=A_4(171)
> VID = A and pop A;
> GVID = A and pop A;

-> 뭔가 결국 X와 Y를 없애는 방향으로 가는게 좋을 것 같다. -> 없애도 문제가 없는가?
-> 애초에 AXBY 하고 연산을 하면 결국 A와 B의 값을 A로 쓰는 것이고, X와 Y의 용도는 그것 뿐이다.
-> 지금 컴파일 후 asm 을 기록하는 부분에서 리터럴 상수를 사용하고 있는데, 이 상수를 추적하여 
-> 실제 쓰이는 명령과 아닌 명령을 구분짓고, 쓸모없는 명령은 버릴 수 있다. 255 ~ 219 까지 함
-> 만약 0 까지 끝내면, 
1. XY의 존재 의의를 알 수 있다.(지울 수 있을지),  ->  가능
2. 핵심 명령만 남길 수 있음 (switch라서) > 그리고 명령 인코딩이 바뀌여도 제대로 돌아감. -> 완료
3. 이후 수정이 자유로워지고, 새로운 명령 추가할 공간도 늘어남. -> 완료
4. 많이 보이는 명령 패턴들이 컴파일 함수 안에 그대로 있을 경우 줄임 명령을 만들어도 된다는 신호 감지. -> 하고 있음
이 네가지를 중점적으로 알아보아야 함.