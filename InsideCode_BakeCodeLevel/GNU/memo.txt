앞으로의 방향성 정하기
1. 일단 어떤 프로그램을 돌릴 수 있는지 확인 - 꽤나 복잡한 프로그램이여야 함
2. 디버깅 방법을 만들어야 겠음 기존 디버깅으로는 부족함. (코드 에디터를 만들까?)
3. 프로그램을 만들면서 부족한 기능들을 체워야함.
4. 어셈 공부 게속

> 게임을 만들어 보자.
SFML의 드로우 명령, 기초적 폰트 출력 등. 기반 인스트럭션을 만들어야함.
힙메모리와 구조체,클레스를 많이 사용하는 게임. 슈팅게임?

> 일단 C++로 먼저 만들고, 그걸 따라가는 식으로 하자.

> 게임을 개발하면서 더 많은 기능들을 게속 넣어보자. 게임속 코딩이라던지. 뭐 여러가지.

> 코드 에디터 만들때 문제
    1. 텍스트 선택(불규칙한 문자의 크기 문제), 복사, 붙여넣기, intellisence, 되돌리기, 등등
    2. 프로그램용 코딩용 키보드 만들어야 됨.
> C4droid에서 아쉬웠던거
    1. 코드 접기 / 펼치기
    2. 문장 변수 함께 검색 / 리플레이스
    3. 중단점이 번호에 종속됨. - 코드에 종속되도록 하자.
    4. 실행중 중단점 추가
    5. Watcher 항목 다양화 / 힙도 볼 수 있게 만들기 / 포인터 배열 보기?
    6. 호출스택 기록
    7. 디버깅중 코드 편집기로 돌아가 탐색 / 디스어셈블러 탐색 가능.
    8. 코드를 쓰면 코드 실행 비용 표시.
    9. 접근성 높은 설정

> 만들어 두면 이후에 만들 프로그램들에 확실한 도움이 될 것이다.

> 헤더파일 만으로 내장함수 만들기? 가능?
일단 함수들을 쓰고..
그 함수를 어디에 asm 어디에 배치할지 결정
extern 을 써서 extend_inst 배열을 조종 (ushort)

일단 포인터 연산과 값 연산의 차이 때문에 일어나는 오류들은 
포인터 연산 > (ptr state = true) > 값연산(만약 매개변수의 ptr state가 true면 풀고 시작.)
이렇게 처리하자.
temp_mem 의 valuetype이 -1이면 ptrstate라 하자. (value type 이 아닌 상태니까..)

ptr oper state 걸때
result_ten->memsiz = result_ten->mem.size();
result_ten->valuetype_detail = get_addpointer_type(member_td);
result_ten->valuetype = - 1 - get_int_with_basictype(member_td); // ptr

value 로 풀때
result_ten->valuetype_detail = get_sub_type(member_td);
result_ten->valuetype = - 1 - result_ten->valuetype; // ptr


///////////////

get_asm_from_sen 에 대한 정리가 다시 필요할듯?
1. temp_mem 구조체 재정의
 - memsiz 제거 mem.size로 대체.
 - char registerMod = 'A' / 'B' ...
 - char isValue = true / false
2. 포인터연산 / 값연산 구분
3. A > B, B > A
 - PUSH_A_FROM_B, 
 - PUSH_B_FROM_A 연산 만들기 > 근데 쓰일지는 모르겠음.
>> done.

FUNC 이 두번 연속으로 쌓일때, saveStack을 차례로 저장하는 것이 필요함.??
필요한가?
어차피 rsp나 lsp에서 얻어오는 거 아님? 
FUNC이 두번 연속 오더라도 문제가 없음 왜냐하면
*saveSP = *sp;
++*pc;
딱 이거 두 연산만 처리하는 데, 그 사이에 sp가 변할 일은.. 없는것 같음??
만약 extend func이 sp를 리턴으로써 변경하더라도, 언제나 복귀가 가능.
왜? 어짜피 첫번째 FUNC이 스택을 저장했으니까? 아니지 오류가 생기겠다.
근데 결국 함수 복귀할때 lfsp 로 돌아와서 결국 메모리는 큰 문제 없을 것 같은데..
그럼 그냥 saveSP 만 circular로 만들면 되겠다.
뭐 한 문장에 32개 연달아 중첩함수를 쓰진 않을 것 아닌가...?